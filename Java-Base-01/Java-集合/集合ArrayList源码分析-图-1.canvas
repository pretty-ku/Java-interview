{
	"nodes":[
		{"id":"792f0048d673bd54","x":-936,"y":1190,"width":2176,"height":640,"type":"group","label":"核心纽带"},
		{"id":"eaaff82e77649172","type":"text","text":"```mermaid\ngraph LR\nA(开始) --> B(创建ArrayList对象)\nB --> C(检查是否需要扩容)\nC -- 是 --> D(扩容数组)\nD --> E(将元素添加到数组末尾)\nE --> F(更新ArrayList的size)\nF --> G(结束)\nC -- 否 --> E\n```\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant ArrayList\nUser -> ArrayList: 创建ArrayList对象\nUser -> ArrayList: 添加元素\nArrayList -> ArrayList: 检查是否需要扩容\nArrayList --> ArrayList: 扩容数组\nArrayList --> ArrayList: 将元素添加到数组末尾\nArrayList --> ArrayList: 更新ArrayList的size\nArrayList --> User: 返回添加成功\n```\n","x":1320,"y":1000,"width":1264,"height":1020},
		{"id":"7d7afda40f4f6a39","type":"text","text":"## (size+1 ) 表示添加玩元素之后的最小容量(minCapacity),即size集合的大小,不是下一个应该插入index位置涵义\n\n```java\nprivate Object[] grow() {  \n    return grow(size + 1); //把现有的个数 + 1 ,即 0 +1 =1\n}\n```","x":-916,"y":860,"width":824,"height":240},
		{"id":"e20d291deae4991a","x":-916,"y":380,"width":824,"height":340,"type":"text","text":"```java\n/**  \n * This helper method split out from add(E) to keep method * bytecode size under 35 (the -XX:MaxInlineSize default value), * which helps when add(E) is called in a C1-compiled loop. */private void add(E e, Object[] elementData, int s) {  \n    if (s == elementData.length)  \n        elementData = grow();  \n    //原始数组【没满】,而不需要扩容,直接添加元素\n    elementData[s] = e;  \n    size = s + 1;  \n}\n\n```"},
		{"id":"1cc36b1e4c4241a5","type":"text","text":"```java\n\n/**  \n * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity  \n * @throws OutOfMemoryError if minCapacity is less than zero  \n */\n private Object[] grow(int minCapacity) {  \n    int oldCapacity = elementData.length;  \n\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {  \n\t    //newCapacity 作用: 确认数组新增的实际长度,实际长度包含(原长度)\n        int newCapacity = ArraysSupport.newLength(oldCapacity,  \n                minCapacity - oldCapacity, /* minimum growth */  \n                oldCapacity >> 1           /* preferred growth */);  \n        return elementData = Arrays.copyOf(elementData, newCapacity);  \n    } else {  \n\t    //当初始数组长度为0时,new一个默认10大小的数组,如果实际插入的大小大于10,则以minCapacity实际为准\n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];  \n    }  \n}  \n  \n\n```","x":-916,"y":1210,"width":880,"height":600,"color":"1"},
		{"id":"637a908d1d730635","type":"text","text":"- 最后得到`minCapacity`: **原来`老数组`的实际长度 + (程序员)添加元素的总个数**  ---如果超过数组长度的最大值 2^32就设置成2^32\n\t- 方法的`ArraysSupport.newLength(oldCapacity,  minCapacity -oldCapacity,oldCapacity >> 1); `参数\n\t- oldCapacity: **原来`老数组`的的最大容量**\n\t- minCapacity - oldCapacity, **至少需要新增的容量,以实际为主** 最小的增长量，即至少要增长多少长度。\n\t- oldCapacity >> 1   //**Java,默认新增容量为原来的1.5倍** \n\t\t- oldCapacity >> 1 即- `prefGrowth`: 首选的增长量，即程序偏好的增长长度。\n\n## Arrays.copyOf(elementData, newCapacity);作用\nreturn elementData = Arrays.copyOf(elementData, newCapacity{**Tips : int, 新增的实际长度**}  );  \n//作用: 拷贝数组`原elementData的数据到`新的数组中, `newCapacity`实际**新建的数组长度**","x":340,"y":1296,"width":880,"height":429,"color":"1"},
		{"id":"f7f1e922af448b07","type":"text","text":"```java\npublic static int newLength(int oldLength, int minGrowth, int prefGrowth) {  \n    // preconditions not checked because of inlining  \n    // assert oldLength >= 0    // assert minGrowth > 0\n    //  👉👉右边解释\n    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow  \n    if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {  \n        return prefLength;  \n    } else {  \n        // put code cold in a separate method  \n        return hugeLength(oldLength, minGrowth);  \n    }  \n}\n```","x":-916,"y":2120,"width":919,"height":355},
		{"id":"0a7f2b4c5b3056fe","type":"text","text":"# public static int newLength(**int oldLength**, **int minGrowth**, int prefGrowth)方法的作用\n## 第一种情况：如果一次添加一个元素，那么第二个参数`minGrowth`一定是1，表示此时数组只要扩容1个单位就可以了。\n## 第二种情况：如果一次添加多个元素，假设100.那么第二个参数`minGrowth`是100，表示此时数组需要扩容100个单位才可以,**不按照默认的1.5倍扩容**","x":203,"y":2120,"width":700,"height":355,"color":"1"},
		{"id":"8d2f965d7ddc2603","type":"text","text":"` modCount++;  `\n\n在这段代码中，`modCount` 是一个计数器，用于记录列表被修改的次数。通常在 Java 的集合类中，例如 `ArrayList`，`modCount` 是用来支持并发修改检测的机制之一。\n\n具体来说：\n- 当列表结构发生变化时（比如添加或删除元素），`modCount` 会增加。\n- 当进行迭代操作时，会检查当前的 `modCount` 是否和迭代开始时记录的 `expectedModCount` 相等，以此来判断在迭代过程中是否有其他线程修改了列表，从而避免并发修改异常（ConcurrentModificationException）的发生。\n\n在你提供的代码中，每次调用 `add(E e)` 方法时，都会增加 `modCount` 的值，以反映列表的修改状态。**","x":-176,"y":-430,"width":580,"height":379,"color":"1"},
		{"id":"8d9b1928de37f9e1","type":"text","text":"`e`参数一：当前要添加的元素；\n`elementData`参数二：集合底层的数组名字\n`size` 参数三：**集合的长度/当前元素应存入的位置**","x":-176,"y":-23,"width":558,"height":105,"color":"1"},
		{"id":"524b6f8add416e77","x":624,"y":-99,"width":676,"height":359,"type":"text","text":"| 元素          | 索引       | **size 涵义: ①集合的长度 ②下一个应该插入index位置** |\n| ----------- | -------- | ----------------------------------- |\n| 00          | `{ }`空数组 | 0                                   |\n| 10          | 0        | 1                                   |\n| 20          | 1        | 2                                   |\n| 30          | 2        | 3                                   |\n| 40          | 3        | 4                                   |\n| 50          | 4        | 5                                   |\n| ........... |          |                                     |\n| 100         | 9        | **10**                              |\n| 110         | 10       | **11**                              |\n"},
		{"id":"405334f9d00e4822","type":"text","text":"```java\ntransient Object[] elementData; // non-private to simplify nested class access\n\n```","x":-916,"y":-640,"width":620,"height":140,"color":"1"},
		{"id":"12d8ddf17b823215","type":"text","text":"```java\n\n/**  \n * The size of the ArrayList (the number of elements it contains). * * @serial  \n */  \nprivate int size;\n```","x":-916,"y":-480,"width":620,"height":157},
		{"id":"7c34908c0f7e7047","type":"text","text":"```java\npublic ArrayList() {  \n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  \n}\n```\n","x":-916,"y":-303,"width":620,"height":124,"color":"4"},
		{"id":"26f1182623994bbb","type":"text","text":"```java\n * Appends the specified element to the end of this list. * * @param e element to be appended to this list  \n * @return {@code true} (as specified by {@link Collection#add})  \n **/\n\n public boolean add(E e) {  \n    modCount++;  \n    add(e, elementData, size);  \n    return true;  \n/*\n\tadd(e, elementData, size);\n\t参数一：当前要添加的元素；\n\t参数二：集合底层的数组名字\n\t参数三：集合的长度/当前元素应存入的位置\n*/\n}\n```  ","x":-916,"y":-159,"width":620,"height":320,"color":"6"},
		{"id":"de60d8b5ba93a4e3","type":"text","text":"## ArrayList:集合底层原理\n### ①利用空参创建的集合，在底层创建一个默认长度为0的数组\n### ②添加第一个元素时，底层会创建一个新的长度为10的数组\n### ③存满时，会扩容1.5倍\n### ④如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准","x":-336,"y":-1280,"width":900,"height":340,"color":"5"},
		{"id":"a5e34a529d66181e","x":1752,"y":-590,"width":400,"height":350,"color":"2","type":"text","text":"# 贯彻的思维指导\n\n## **多重解释能力,角度一一对应的适应性思维**\n不同场景,适用不同的解释,不要混淆了.要一一对应"}
	],
	"edges":[
		{"id":"8a2b30a9b265dad4","fromNode":"26f1182623994bbb","fromSide":"right","toNode":"8d9b1928de37f9e1","toSide":"left"},
		{"id":"80c7c2a63b7bd8f8","fromNode":"1cc36b1e4c4241a5","fromSide":"right","toNode":"637a908d1d730635","toSide":"left"},
		{"id":"094646da46025e1e","fromNode":"f7f1e922af448b07","fromSide":"right","toNode":"0a7f2b4c5b3056fe","toSide":"left"},
		{"id":"c48a8732b780c493","fromNode":"26f1182623994bbb","fromSide":"right","toNode":"8d2f965d7ddc2603","toSide":"left"},
		{"id":"33da87b9ed4fb4b1","fromNode":"8d9b1928de37f9e1","fromSide":"right","toNode":"524b6f8add416e77","toSide":"left"},
		{"id":"cbee47104bdaa375","fromNode":"e20d291deae4991a","fromSide":"bottom","toNode":"7d7afda40f4f6a39","toSide":"top"},
		{"id":"66927e7e74ae55d2","fromNode":"a5e34a529d66181e","fromSide":"left","toNode":"524b6f8add416e77","toSide":"right"}
	]
}
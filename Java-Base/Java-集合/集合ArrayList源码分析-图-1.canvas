{
	"nodes":[
		{"id":"405334f9d00e4822","type":"text","text":"```java\ntransient Object[] elementData; // non-private to simplify nested class access\n\n```","x":-860,"y":-480,"width":620,"height":140,"color":"1"},
		{"id":"12d8ddf17b823215","type":"text","text":"```java\n\n/**  \n * The size of the ArrayList (the number of elements it contains). * * @serial  \n */  \nprivate int size;\n```","x":-860,"y":-320,"width":620,"height":157},
		{"id":"26f1182623994bbb","type":"text","text":"```java\n * Appends the specified element to the end of this list. * * @param e element to be appended to this list  \n * @return {@code true} (as specified by {@link Collection#add})  \n **/\n\n public boolean add(E e) {  \n    modCount++;  \n    add(e, elementData, size);  \n    return true;  \n/*\n\tadd(e, elementData, size);\n\t参数一：当前要添加的元素；\n\t参数二：集合底层的数组名字\n\t参数三：集合的长度/当前元素应存入的位置\n*/\n}\n```  ","x":-860,"y":1,"width":620,"height":320,"color":"6"},
		{"id":"7c34908c0f7e7047","type":"text","text":"```java\npublic ArrayList() {  \n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  \n}\n```\n","x":-860,"y":-143,"width":620,"height":124,"color":"4"},
		{"id":"8d9b1928de37f9e1","type":"text","text":"`e`参数一：当前要添加的元素；\n`elementData`参数二：集合底层的数组名字\n`size` 参数三：**集合的长度/当前元素应存入的位置**","x":-120,"y":137,"width":558,"height":105,"color":"1"},
		{"id":"7d7afda40f4f6a39","type":"text","text":"## (size+1 ) 表示添加玩元素之后的最小容量(minCapacity)\n\n```java\nprivate Object[] grow() {  \n    return grow(size + 1); //把现有的个数 + 1 ,即 0 +1 =1\n}\n```","x":-860,"y":321,"width":824,"height":240},
		{"id":"1cc36b1e4c4241a5","type":"text","text":"```java\n\n/**  \n * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity  \n * @throws OutOfMemoryError if minCapacity is less than zero  \n */private Object[] grow(int minCapacity) {  \n    int oldCapacity = elementData.length;  \n\n    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {  \n\t    //newCapacity 作用: 确认数组新增的实际长度,实际长度包含(原长度)\n        int newCapacity = ArraysSupport.newLength(oldCapacity,  \n                minCapacity - oldCapacity, /* minimum growth */  \n                oldCapacity >> 1           /* preferred growth */);  \n        return elementData = Arrays.copyOf(elementData, newCapacity);  \n    } else {  \n        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];  \n    }  \n}  \n  \n\n```","x":-916,"y":581,"width":880,"height":600},
		{"id":"f7f1e922af448b07","type":"text","text":"```java\npublic static int newLength(int oldLength, int minGrowth, int prefGrowth) {  \n    // preconditions not checked because of inlining  \n    // assert oldLength >= 0    // assert minGrowth > 0  \n    int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow  \n    if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) {  \n        return prefLength;  \n    } else {  \n        // put code cold in a separate method  \n        return hugeLength(oldLength, minGrowth);  \n    }  \n}\n```","x":-579,"y":1360,"width":919,"height":355},
		{"id":"0a7f2b4c5b3056fe","type":"text","text":"# public static int newLength(**int oldLength**, **int minGrowth**, int prefGrowth)方法的作用\n## 第一种情况：如果一次添加一个元素，那么第二个参数`minGrowth`一定是1，表示此时数组只要扩容1个单位就可以了。\n## 第二种情况：如果一次添加多个元素，假设100.那么第二个参数`minGrowth`是100，表示此时数组需要扩容100个单位才可以,**不按照默认的1.5倍扩容**","x":540,"y":1360,"width":700,"height":355,"color":"1"},
		{"id":"de60d8b5ba93a4e3","type":"text","text":"## ArrayList:集合底层原理\n### ①利用空参创建的集合，在底层创建一个默认长度为0的数组\n### ②添加第一个元素时，底层会创建一个新的长度为10的数组\n### ③存满时，会扩容1.5倍\n### ④如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准","x":720,"y":-150,"width":900,"height":340,"color":"5"},
		{"id":"eaaff82e77649172","type":"text","text":"```mermaid\ngraph LR\nA(开始) --> B(创建ArrayList对象)\nB --> C(检查是否需要扩容)\nC -- 是 --> D(扩容数组)\nD --> E(将元素添加到数组末尾)\nE --> F(更新ArrayList的size)\nF --> G(结束)\nC -- 否 --> E\n```\n```mermaid\nsequenceDiagram\nparticipant User\nparticipant ArrayList\nUser -> ArrayList: 创建ArrayList对象\nUser -> ArrayList: 添加元素\nArrayList -> ArrayList: 检查是否需要扩容\nArrayList --> ArrayList: 扩容数组\nArrayList --> ArrayList: 将元素添加到数组末尾\nArrayList --> ArrayList: 更新ArrayList的size\nArrayList --> User: 返回添加成功\n```\n","x":1320,"y":441,"width":1264,"height":1020},
		{"id":"637a908d1d730635","type":"text","text":"- minCapacity: **原来`老数组`的实际长度 + (程序员)添加元素的总个数**\n\t- oldCapacity: **原来`老数组`的的最大容量**\n\t- minCapacity - oldCapacity, **至少需要新增的容量,以实际为主** 最小的增长量，即至少要增长多少长度。\n\t- oldCapacity >> 1   //**Java,默认新增容量为原来的1.5倍** \n\t\t- oldCapacity >> 1 即- `prefGrowth`: 首选的增长量，即程序偏好的增长长度。\n\n## Arrays.copyOf(elementData, newCapacity);作用\nreturn elementData = Arrays.copyOf(elementData, newCapacity{**Tips : int, 新增的实际长度**}  );  \n//作用: 拷贝数组`原elementData的数据到`新的数组中, `newCapacity`实际**新建的数组长度**","x":340,"y":711,"width":640,"height":340,"color":"1"},
		{"id":"8d2f965d7ddc2603","type":"text","text":"` modCount++;  `\n\n在这段代码中，`modCount` 是一个计数器，用于记录列表被修改的次数。通常在 Java 的集合类中，例如 `ArrayList`，`modCount` 是用来支持并发修改检测的机制之一。\n\n具体来说：\n- 当列表结构发生变化时（比如添加或删除元素），`modCount` 会增加。\n- 当进行迭代操作时，会检查当前的 `modCount` 是否和迭代开始时记录的 `expectedModCount` 相等，以此来判断在迭代过程中是否有其他线程修改了列表，从而避免并发修改异常（ConcurrentModificationException）的发生。\n\n在你提供的代码中，每次调用 `add(E e)` 方法时，都会增加 `modCount` 的值，以反映列表的修改状态。**","x":-120,"y":-270,"width":580,"height":379,"color":"1"}
	],
	"edges":[
		{"id":"8a2b30a9b265dad4","fromNode":"26f1182623994bbb","fromSide":"right","toNode":"8d9b1928de37f9e1","toSide":"left"},
		{"id":"80c7c2a63b7bd8f8","fromNode":"1cc36b1e4c4241a5","fromSide":"right","toNode":"637a908d1d730635","toSide":"left"},
		{"id":"094646da46025e1e","fromNode":"f7f1e922af448b07","fromSide":"right","toNode":"0a7f2b4c5b3056fe","toSide":"left"},
		{"id":"c48a8732b780c493","fromNode":"26f1182623994bbb","fromSide":"right","toNode":"8d2f965d7ddc2603","toSide":"left"}
	]
}